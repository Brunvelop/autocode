<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autocode Chat - Integration Tests</title>
    <style>
        body {
            padding: 2rem;
            background-color: #f3f4f6;
            min-height: 100vh;
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
        }
        .link {
            color: #4f46e5;
            text-decoration: none;
        }
        .link:hover {
            color: #4338ca;
        }
        .header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }
        .title {
            font-size: 1.875rem;
            font-weight: bold;
            margin: 0;
        }
        .subtitle {
            color: #4b5563;
            margin-bottom: 1rem;
        }
        .status-box {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: #fef3c7;
            border: 1px solid #fcd34d;
            border-radius: 0.5rem;
            color: #92400e;
        }
        .summary, .results {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        .results {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="/tests" class="link">‚Üê Tests</a>
        <h1 class="title">üó®Ô∏è Autocode Chat - Integration Tests</h1>
    </div>
    <p class="subtitle">Tests del componente de chat integrado.</p>

    <!-- Server Status -->
    <div id="serverStatus" class="status-box">
        <span>‚è≥ Verificando conexi√≥n con el servidor...</span>
    </div>

    <div id="summary" class="summary"></div>
    <div id="results" class="results"></div>

    <script type="module">
        import { TestRunner } from '../utils/test-runner.js';

        const runner = new TestRunner();

        // Helper para crear chat en el stage actual
        const createChat = async (stage) => {
            await runner.waitForElement('autocode-chat');
            const el = document.createElement('autocode-chat');
            if (stage) stage.appendChild(el);
            // Dar tiempo a que se renderice shadow DOM
            await runner.sleep(100);
            return el;
        };

        // ============================================
        // TESTS: Renderizado
        // ============================================

        runner.test('autocode-chat: se puede crear', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el, 'Debe poder crear el elemento');
        }, { requiresServer: true });

        runner.test('autocode-chat: renderiza chat-window', async (stage) => {
            const el = await createChat(stage);
            // Ahora est√° en Shadow DOM
            const window = el.shadowRoot.querySelector('chat-window');
            runner.assertTrue(window, 'Debe tener chat-window');
        }, { requiresServer: true });

        runner.test('autocode-chat: renderiza chat-messages', async (stage) => {
            const el = await createChat(stage);
            const messages = el.shadowRoot.querySelector('chat-messages');
            runner.assertTrue(messages, 'Debe tener chat-messages');
        }, { requiresServer: true });

        runner.test('autocode-chat: renderiza chat-input', async (stage) => {
            const el = await createChat(stage);
            const input = el.shadowRoot.querySelector('chat-input');
            runner.assertTrue(input, 'Debe tener chat-input');
        }, { requiresServer: true });

        runner.test('autocode-chat: renderiza context-bar', async (stage) => {
            const el = await createChat(stage);
            const contextBar = el.shadowRoot.querySelector('context-bar');
            runner.assertTrue(contextBar, 'Debe tener context-bar');
        }, { requiresServer: true });

        runner.test('autocode-chat: renderiza bot√≥n Nueva', async (stage) => {
            const el = await createChat(stage);
            // Ahora el bot√≥n est√° en Shadow DOM
            const newBtn = el.shadowRoot.querySelector('[data-ref="newChatBtn"]');
            runner.assertTrue(newBtn, 'Debe tener bot√≥n Nueva');
            runner.assertContains(newBtn.textContent, 'Nueva');
        }, { requiresServer: true });

        // ============================================
        // TESTS: Referencias internas
        // ============================================

        runner.test('autocode-chat: tiene _window', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el._window, '_window debe existir');
        }, { requiresServer: true });

        runner.test('autocode-chat: tiene _messages', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el._messages, '_messages debe existir');
        }, { requiresServer: true });

        runner.test('autocode-chat: tiene _input', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el._input, '_input debe existir');
        }, { requiresServer: true });

        runner.test('autocode-chat: tiene _contextBar', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el._contextBar, '_contextBar debe existir');
        }, { requiresServer: true });

        runner.test('autocode-chat: tiene conversationHistory inicializado', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(Array.isArray(el.conversationHistory), 'conversationHistory debe ser un array');
        }, { requiresServer: true });

        // ============================================
        // TESTS: Funcionalidad Nueva Conversaci√≥n
        // ============================================

        runner.test('autocode-chat: bot√≥n Nueva limpia mensajes', async (stage) => {
            const el = await createChat(stage);

            // A√±adir mensajes de prueba
            el._messages?.addMessage('user', 'Test message 1');
            el._messages?.addMessage('assistant', 'Test response 1');

            await runner.sleep(50);

            let messages = el._messages?.shadowRoot?.querySelectorAll('[data-role]');
            runner.assertTrue(messages?.length >= 2, 'Debe tener mensajes antes de limpiar');

            // Click en Nueva
            const newBtn = el.shadowRoot.querySelector('[data-ref="newChatBtn"]');
            newBtn?.click();

            await runner.sleep(50);

            // Verificar que se limpiaron
            messages = el._messages?.shadowRoot?.querySelectorAll('[data-role]');
            runner.assertEqual(messages?.length || 0, 0, 'Mensajes deben estar vac√≠os despu√©s de Nueva');
        }, { requiresServer: true });

        runner.test('autocode-chat: bot√≥n Nueva limpia historial', async (stage) => {
            const el = await createChat(stage);

            // Simular historial
            el.conversationHistory = [
                { role: 'user', content: 'Test' },
                { role: 'assistant', content: 'Response' }
            ];

            // Click en Nueva
            const newBtn = el.shadowRoot.querySelector('[data-ref="newChatBtn"]');
            newBtn?.click();

            await runner.sleep(50);

            runner.assertEqual(el.conversationHistory.length, 0, 'Historial debe estar vac√≠o');
        }, { requiresServer: true });

        // ============================================
        // TESTS: UI Optimista
        // ============================================

        runner.test('autocode-chat: submit a√±ade mensaje de usuario inmediatamente', async (stage) => {
            const el = await createChat(stage);

            // Limpiar primero
            el._handleNewChat?.();

            // Simular submit
            const testMessage = 'Mensaje de prueba ' + Date.now();
            el._input?.dispatchEvent(new CustomEvent('submit', {
                detail: { message: testMessage },
                bubbles: true,
                composed: true
            }));

            await runner.sleep(50);

            // Verificar que el mensaje del usuario aparece inmediatamente
            const userMessages = el._messages?.shadowRoot?.querySelectorAll('[data-role="user"]');
            runner.assertTrue(userMessages?.length > 0, 'Debe haber al menos un mensaje de usuario');

            const lastUserMsg = userMessages[userMessages.length - 1];
            runner.assertContains(lastUserMsg.textContent, testMessage, 'El mensaje debe contener el texto enviado');
        }, { requiresServer: true });

        runner.test('autocode-chat: submit no a√±ade mensaje vac√≠o', async (stage) => {
            const el = await createChat(stage);

            // Limpiar primero
            el._handleNewChat?.();

            const initialCount = el._messages?.shadowRoot?.querySelectorAll('[data-role]')?.length || 0;

            // Simular submit vac√≠o
            el._input?.dispatchEvent(new CustomEvent('submit', {
                detail: { message: '' },
                bubbles: true,
                composed: true
            }));

            await runner.sleep(50);

            const finalCount = el._messages?.shadowRoot?.querySelectorAll('[data-role]')?.length || 0;
            runner.assertEqual(finalCount, initialCount, 'No debe a√±adir mensaje vac√≠o');
        }, { requiresServer: true });

        // ============================================
        // TESTS: Toggle de ventana
        // ============================================

        runner.test('autocode-chat: toggle abre la ventana', async (stage) => {
            const el = await createChat(stage);

            // Cerrar primero
            el._window?.close();

            await runner.sleep(50);

            // Abrir con toggle
            el._window?.toggle();

            await runner.sleep(100);

            // Verificar que est√° abierto
            runner.assertTrue(el._window?.open, 'La ventana debe estar abierta');
        }, { requiresServer: true });

        runner.test('autocode-chat: toggle cierra la ventana', async (stage) => {
            const el = await createChat(stage);

            // Abrir primero
            el._window?.openWindow();

            await runner.sleep(50);

            // Cerrar con toggle
            el._window?.toggle();

            await runner.sleep(100);

            // Verificar que est√° cerrado
            runner.assertFalse(el._window?.open, 'La ventana debe estar cerrada');
        }, { requiresServer: true });

        // ============================================
        // TESTS: M√©todos showResult
        // ============================================

        runner.test('autocode-chat: _processResult a√±ade mensaje del asistente', async (stage) => {
            const el = await createChat(stage);

            el._handleNewChat?.();

            // Simular resultado
            el._processResult({ result: { response: 'Respuesta del asistente' } });

            await runner.sleep(50);

            const assistantMessages = el._messages?.shadowRoot?.querySelectorAll('[data-role="assistant"]');
            runner.assertTrue(assistantMessages?.length > 0, 'Debe haber mensaje del asistente');
        }, { requiresServer: true });

        runner.test('autocode-chat: _processResult con error muestra mensaje de error', async (stage) => {
            const el = await createChat(stage);

            el._handleNewChat?.();

            // Simular error
            el._processResult({ _isError: true, _message: 'Error de prueba' });

            await runner.sleep(50);

            const errorMessages = el._messages?.shadowRoot?.querySelectorAll('[data-role="error"]');
            runner.assertTrue(errorMessages?.length > 0, 'Debe haber mensaje de error');
        }, { requiresServer: true });

        // ============================================
        // TESTS: Settings
        // ============================================

        runner.test('autocode-chat: renderiza chat-settings', async (stage) => {
            const el = await createChat(stage);
            const settings = el.shadowRoot.querySelector('chat-settings');
            runner.assertTrue(settings, 'Debe tener chat-settings');
            runner.assertTrue(el._settings, 'Debe tener referencia _settings');
        }, { requiresServer: true });

        runner.test('autocode-chat: badge de modelo se actualiza reactivamente', async (stage) => {
            const el = await createChat(stage);
            
            // Mock funcInfo para configurar settings
            el.funcInfo = {
                parameters: [{ name: 'model', default: 'gpt-4o' }]
            };
            el._settings?.configure(el.funcInfo);
            
            await runner.sleep(50);
            
            // Simular cambio en settings
            el._settings?._updateSetting('model', 'claude-3-opus');
            
            await runner.sleep(50);
            
            // El badge deber√≠a actualizarse por reactividad
            runner.assertTrue(true, 'Settings update completa');
        }, { requiresServer: true });

        // ============================================
        // TESTS: Mensajes Ricos (Integraci√≥n)
        // ============================================

        runner.test('autocode-chat: _processResult con reasoning lo pasa a mensajes', async (stage) => {
            const el = await createChat(stage);
            el._handleNewChat?.();

            const complexResponse = {
                result: { response: 'Respuesta final' },
                reasoning: 'Reasoning integration test'
            };
            
            el._processResult(complexResponse);
            await runner.sleep(50);
            
            // Verificar en el DOM de chat-messages (Shadow DOM)
            const messagesEl = el._messages;
            const reasoningEl = messagesEl?.shadowRoot?.querySelector('[data-type="reasoning"]');
            runner.assertTrue(reasoningEl, 'Debe renderizar reasoning');
            runner.assertTrue(reasoningEl?.textContent.includes('Reasoning integration'), 'Debe contener el texto');
        }, { requiresServer: true });

        runner.test('autocode-chat: maneja errores de backend gracefully', async (stage) => {
            const el = await createChat(stage);
            el._handleNewChat?.();

            // Simular respuesta de error del backend (DspyOutput success=False)
            const errorResponse = {
                success: false,
                message: "Error de validaci√≥n Pydantic",
                result: {}
            };
            
            el._processResult(errorResponse);
            await runner.sleep(50);
            
            // Verificar que se muestra como ERROR, no como asistente
            const errorMsgs = el._messages?.shadowRoot?.querySelectorAll('[data-role="error"]');
            runner.assertEqual(errorMsgs?.length || 0, 1, 'Debe haber 1 mensaje de error');
            runner.assertTrue(errorMsgs?.[0]?.textContent.includes('Error de validaci√≥n'), 'Debe mostrar el mensaje de error');
            
            // Verificar que NO se muestra como asistente
            const assistantMsgs = el._messages?.shadowRoot?.querySelectorAll('[data-role="assistant"]');
            runner.assertEqual(assistantMsgs?.length || 0, 0, 'No debe haber mensaje de asistente');
        }, { requiresServer: true });

        // ============================================
        // IMPORTAR Y EJECUTAR
        // ============================================

        try {
            await import('/elements/auto-element-generator.js');
        } catch (e) {
            console.warn('auto-element-generator.js no cargado:', e.message);
        }

        await runner.sleep(1000);

        try {
            await import('/elements/chat/index.js');
        } catch (e) {
            console.warn('autocode-chat.js no cargado:', e.message);
        }

        await runner.sleep(500);
        await runner.run();
    </script>
</body>
</html>
