<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autocode Chat - Integration Tests</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="p-8 bg-gray-100 min-h-screen">
    <div class="flex items-center gap-4 mb-2">
        <a href="/tests" class="text-indigo-600 hover:text-indigo-800">‚Üê Tests</a>
        <h1 class="text-3xl font-bold">üó®Ô∏è Autocode Chat - Integration Tests</h1>
    </div>
    <p class="text-gray-600 mb-4">Tests del componente de chat integrado.</p>

    <!-- Server Status -->
    <div id="serverStatus" class="mb-6 p-4 bg-yellow-100 border border-yellow-300 rounded-lg">
        <span class="text-yellow-800">‚è≥ Verificando conexi√≥n con el servidor...</span>
    </div>

    <div id="summary" class="mb-6 p-4 bg-white rounded-lg shadow"></div>
    <div id="results" class="space-y-2"></div>

    <!-- (Eliminado Test Area global, ahora cada test gestiona su UI) -->

    <script type="module">
        import { TestRunner } from '../utils/test-runner.js';

        const runner = new TestRunner();

        // Helper para crear chat en el stage actual
        const createChat = async (stage) => {
            await runner.waitForElement('autocode-chat');
            const el = document.createElement('autocode-chat');
            if (stage) stage.appendChild(el);
            // Dar tiempo a que se renderice shadow DOM
            await runner.sleep(50);
            return el;
        };

        // ============================================
        // TESTS: Renderizado
        // ============================================

        runner.test('autocode-chat: se puede crear', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el, 'Debe poder crear el elemento');
        }, { requiresServer: true });

        runner.test('autocode-chat: renderiza chat-window', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el.querySelector('chat-window'), 'Debe tener chat-window');
        }, { requiresServer: true });

        runner.test('autocode-chat: renderiza chat-messages', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el.querySelector('chat-messages'), 'Debe tener chat-messages');
        }, { requiresServer: true });

        runner.test('autocode-chat: renderiza chat-input', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el.querySelector('chat-input'), 'Debe tener chat-input');
        }, { requiresServer: true });

        runner.test('autocode-chat: renderiza context-bar', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el.querySelector('context-bar'), 'Debe tener context-bar');
        }, { requiresServer: true });

        runner.test('autocode-chat: renderiza bot√≥n Nueva', async (stage) => {
            const el = await createChat(stage);
            const newBtn = el.querySelector('[data-ref="newChatBtn"]');
            runner.assertTrue(newBtn, 'Debe tener bot√≥n Nueva');
            runner.assertContains(newBtn.textContent, 'Nueva');
        }, { requiresServer: true });

        // ============================================
        // TESTS: Referencias internas
        // ============================================

        runner.test('autocode-chat: tiene _window', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el._window, '_window debe existir');
        }, { requiresServer: true });

        runner.test('autocode-chat: tiene _messages', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el._messages, '_messages debe existir');
        }, { requiresServer: true });

        runner.test('autocode-chat: tiene _input', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el._input, '_input debe existir');
        }, { requiresServer: true });

        runner.test('autocode-chat: tiene _contextBar', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el._contextBar, '_contextBar debe existir');
        }, { requiresServer: true });

        runner.test('autocode-chat: tiene conversationHistory inicializado', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(Array.isArray(el.conversationHistory), 'conversationHistory debe ser un array');
        }, { requiresServer: true });

        // ============================================
        // TESTS: Funcionalidad Nueva Conversaci√≥n
        // ============================================

        runner.test('autocode-chat: bot√≥n Nueva limpia mensajes', async (stage) => {
            const el = await createChat(stage);

            // A√±adir mensajes de prueba
            el._messages?.addMessage('user', 'Test message 1');
            el._messages?.addMessage('assistant', 'Test response 1');

            let messages = el._messages?.querySelectorAll('[data-role]');
            runner.assertTrue(messages?.length >= 2, 'Debe tener mensajes antes de limpiar');

            // Click en Nueva
            const newBtn = el.querySelector('[data-ref="newChatBtn"]');
            newBtn?.click();

            await runner.sleep(50);

            // Verificar que se limpiaron
            messages = el._messages?.querySelectorAll('[data-role]');
            runner.assertEqual(messages?.length || 0, 0, 'Mensajes deben estar vac√≠os despu√©s de Nueva');
        }, { requiresServer: true });

        runner.test('autocode-chat: bot√≥n Nueva limpia historial', async (stage) => {
            const el = await createChat(stage);

            // Simular historial
            el.conversationHistory = [
                { role: 'user', content: 'Test' },
                { role: 'assistant', content: 'Response' }
            ];

            // Click en Nueva
            const newBtn = el.querySelector('[data-ref="newChatBtn"]');
            newBtn?.click();

            await runner.sleep(50);

            runner.assertEqual(el.conversationHistory.length, 0, 'Historial debe estar vac√≠o');
        }, { requiresServer: true });

        // ============================================
        // TESTS: UI Optimista
        // ============================================

        runner.test('autocode-chat: submit a√±ade mensaje de usuario inmediatamente', async (stage) => {
            const el = await createChat(stage);

            // Limpiar primero
            el._handleNewChat?.();

            // Simular submit
            const testMessage = 'Mensaje de prueba ' + Date.now();
            el._input?.dispatchEvent(new CustomEvent('submit', {
                detail: { message: testMessage }
            }));

            await runner.sleep(50);

            // Verificar que el mensaje del usuario aparece inmediatamente
            const userMessages = el._messages?.querySelectorAll('[data-role="user"]');
            runner.assertTrue(userMessages?.length > 0, 'Debe haber al menos un mensaje de usuario');

            const lastUserMsg = userMessages[userMessages.length - 1];
            runner.assertContains(lastUserMsg.textContent, testMessage, 'El mensaje debe contener el texto enviado');
        }, { requiresServer: true });

        runner.test('autocode-chat: submit no a√±ade mensaje vac√≠o', async (stage) => {
            const el = await createChat(stage);

            // Limpiar primero
            el._handleNewChat?.();

            const initialCount = el._messages?.querySelectorAll('[data-role]')?.length || 0;

            // Simular submit vac√≠o
            el._input?.dispatchEvent(new CustomEvent('submit', {
                detail: { message: '' }
            }));

            await runner.sleep(50);

            const finalCount = el._messages?.querySelectorAll('[data-role]')?.length || 0;
            runner.assertEqual(finalCount, initialCount, 'No debe a√±adir mensaje vac√≠o');
        }, { requiresServer: true });

        // ============================================
        // TESTS: Toggle de ventana
        // ============================================

        runner.test('autocode-chat: toggle abre la ventana', async (stage) => {
            const el = await createChat(stage);

            // Cerrar primero
            el._window?.close();

            await runner.sleep(50);

            // Abrir con toggle
            el._window?.toggle();

            await runner.sleep(100);

            // Verificar que est√° abierto
            const panel = el._window?.shadowRoot?.querySelector('[data-ref="panel"]');
            runner.assertFalse(panel?.classList.contains('hidden'), 'Panel debe estar visible');
        }, { requiresServer: true });

        runner.test('autocode-chat: toggle cierra la ventana', async (stage) => {
            const el = await createChat(stage);

            // Abrir primero
            el._window?.open();

            await runner.sleep(50);

            // Cerrar con toggle
            el._window?.toggle();

            await runner.sleep(100);

            // Verificar que est√° cerrado
            const panel = el._window?.shadowRoot?.querySelector('[data-ref="panel"]');
            runner.assertTrue(panel?.classList.contains('hidden'), 'Panel debe estar oculto');
        }, { requiresServer: true });

        // ============================================
        // TESTS: M√©todos showResult
        // ============================================

        runner.test('autocode-chat: showResult a√±ade mensaje del asistente', async (stage) => {
            const el = await createChat(stage);

            el._handleNewChat?.();

            // Simular resultado
            el.showResult({ result: { response: 'Respuesta del asistente' } });

            await runner.sleep(50);

            const assistantMessages = el._messages?.querySelectorAll('[data-role="assistant"]');
            runner.assertTrue(assistantMessages?.length > 0, 'Debe haber mensaje del asistente');
        }, { requiresServer: true });

        runner.test('autocode-chat: showResult con error muestra mensaje de error', async (stage) => {
            const el = await createChat(stage);

            el._handleNewChat?.();

            // Simular error
            el.showResult('Error de prueba', true);

            await runner.sleep(50);

            const errorMessages = el._messages?.querySelectorAll('[data-role="error"]');
            runner.assertTrue(errorMessages?.length > 0, 'Debe haber mensaje de error');
        }, { requiresServer: true });

        // ============================================
        // TESTS: Settings
        // ============================================

        runner.test('autocode-chat: renderiza chat-settings', async (stage) => {
            const el = await createChat(stage);
            runner.assertTrue(el.querySelector('chat-settings'), 'Debe tener chat-settings');
            runner.assertTrue(el._settings, 'Debe tener referencia _settings');
        }, { requiresServer: true });

        runner.test('autocode-chat: badge de modelo se actualiza reactivamente', async (stage) => {
            const el = await createChat(stage);
            
            // Mock funcInfo para configurar settings
            el.funcInfo = {
                parameters: [{ name: 'model', default: 'gpt-4o' }]
            };
            el._settings.configure(el.funcInfo);
            
            await runner.sleep(50);
            
            const badgeName = el.querySelector('[data-ref="modelName"]');
            
            // Simular cambio en settings
            el._settings._updateSetting('model', 'claude-3-opus');
            
            await runner.sleep(50);
            
            runner.assertEqual(badgeName.textContent, 'claude-3-opus', 'El badge debe actualizarse inmediatamente');
        }, { requiresServer: true });

        runner.test('autocode-chat: settings changes propagate to hidden inputs', async (stage) => {
            const el = await createChat(stage);
            
            // Mock funcInfo para configurar settings
            const mockFuncInfo = {
                name: 'chat',
                description: 'Chat function',
                http_methods: ['POST'],
                parameters: [
                    {
                        name: 'model',
                        type: 'str',
                        required: false,
                        default: 'gpt-4o',
                        description: 'Model to use',
                        choices: ['gpt-4o', 'claude-3']
                    },
                    {
                        name: 'message',
                        type: 'str',
                        required: true
                    }
                ]
            };

            // Forzar funcInfo para el test (simulando carga real)
            el.funcInfo = mockFuncInfo;
            // Re-ejecutar l√≥gica de inicializaci√≥n de settings
            if (el._settings) el._settings.configure(mockFuncInfo);
            el._injectHiddenParams();

            await runner.sleep(50);

            // 1. Verificar valor inicial
            // Buscamos el input oculto que usa el generator para enviar
            let modelInput = el.querySelector('input[name="model"][type="hidden"]');
            if (!modelInput) modelInput = el.querySelector('[name="model"]');
            runner.assertTrue(modelInput, 'Debe existir input inicial para model');
            
            // 2. Simular cambio en Settings UI
            const settings = el._settings;
            runner.assertTrue(settings, 'Debe tener componente settings');

            // Cambiar valor en settings (simulando interacci√≥n de usuario)
            // Opci√≥n A: Modificar UI de settings
            const settingsSelect = settings.querySelector('select[name="model"]');
            if (settingsSelect) {
                settingsSelect.value = 'claude-3';
                settingsSelect.dispatchEvent(new Event('change', { bubbles: true }));
            } else {
                // Fallback si la UI no est√° lista, forzamos estado interno
                settings._updateSetting('model', 'claude-3');
            }

            await runner.sleep(50);

            // 3. Simular Env√≠o de Mensaje
            // Esto dispara _handleSubmit -> _updateSettingsParams
            el._handleNewChat(); // Limpiar estado
            el._input.dispatchEvent(new CustomEvent('submit', { 
                detail: { message: 'Test message' } 
            }));

            await runner.sleep(50);

            // 4. VERIFICACI√ìN CR√çTICA
            // El input que usa el generator (el que tiene name="model") debe tener el NUEVO valor
            let finalModelInput = el.querySelector('input[name="model"][type="hidden"]');
            if (!finalModelInput) finalModelInput = el.querySelector('[name="model"]');
            
            const value = finalModelInput.value;
            // console.log('Model value sent:', value);

            runner.assertEqual(value, 'claude-3', 'El input oculto debe actualizarse con la selecci√≥n de settings');

        }, { requiresServer: true });

        // ============================================
        // TESTS: Mensajes Ricos (Integraci√≥n)
        // ============================================

        runner.test('autocode-chat: showResult con reasoning lo pasa a mensajes', async (stage) => {
            const el = await createChat(stage);
            el._handleNewChat?.();

            const complexResponse = {
                result: { response: 'Respuesta final' },
                reasoning: 'Reasoning integration test'
            };
            
            el.showResult(complexResponse);
            await runner.sleep(50);
            
            // Verificar en el DOM de chat-messages
            const messagesEl = el._messages;
            const reasoningEl = messagesEl.querySelector('[data-type="reasoning"]');
            runner.assertTrue(reasoningEl, 'Debe renderizar reasoning');
            runner.assertTrue(reasoningEl.textContent.includes('Reasoning integration'), 'Debe contener el texto');
        }, { requiresServer: true });

        runner.test('autocode-chat: maneja errores de backend gracefully', async (stage) => {
            const el = await createChat(stage);
            el._handleNewChat?.();

            // Simular respuesta de error del backend (DspyOutput success=False)
            const errorResponse = {
                success: false,
                message: "Error de validaci√≥n Pydantic",
                result: {}
            };
            
            el.showResult(errorResponse);
            await runner.sleep(50);
            
            // Verificar que se muestra como ERROR, no como asistente
            const errorMsgs = el._messages.querySelectorAll('[data-role="error"]');
            runner.assertEqual(errorMsgs.length, 1, 'Debe haber 1 mensaje de error');
            runner.assertTrue(errorMsgs[0].textContent.includes('Error de validaci√≥n'), 'Debe mostrar el mensaje de error');
            
            // Verificar que NO se muestra como asistente
            const assistantMsgs = el._messages.querySelectorAll('[data-role="assistant"]');
            runner.assertEqual(assistantMsgs.length, 0, 'No debe haber mensaje de asistente');
        }, { requiresServer: true });

        // ============================================
        // IMPORTAR Y EJECUTAR
        // ============================================

        try {
            await import('/elements/auto-element-generator.js');
        } catch (e) {
            console.warn('auto-element-generator.js no cargado:', e.message);
        }

        await runner.sleep(1000);

        try {
            await import('/elements/chat/autocode-chat.js');
        } catch (e) {
            console.warn('autocode-chat.js no cargado:', e.message);
        }

        await runner.sleep(500);
        await runner.run();
    </script>
</body>
</html>
