<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Visualizer - Integration Tests</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="p-8 bg-gray-100 min-h-screen">
    <div class="flex items-center gap-4 mb-2">
        <a href="/tests" class="text-indigo-600 hover:text-indigo-800">â† Tests</a>
        <h1 class="text-3xl font-bold">ğŸŒ³ Git Visualizer - Integration Tests</h1>
    </div>

    <div id="summary" class="mb-6 p-4 bg-white rounded-lg shadow"></div>
    <div id="results" class="space-y-2"></div>

    <script type="module">
        import { TestRunner } from '../../utils/test-runner.js';

        try {
            await import('/elements/git-visualizer/git-visualizer.js');
        } catch (e) {
            console.warn('git-visualizer.js no encontrado:', e.message);
        }

        const runner = new TestRunner();

        // Mock global de fetch para /get_git_tree
        const mockGitTree = {
            success: true,
            result: {
                name: "root",
                type: "directory",
                children: [
                    { name: "src", type: "directory", children: [{ name: "index.js", type: "file" }] },
                    { name: "README.md", type: "file" }
                ]
            }
        };

        const originalFetch = window.fetch;
        window.fetch = async (url) => {
            if (url === '/get_git_tree') {
                return {
                    ok: true,
                    json: async () => mockGitTree
                };
            }
            return originalFetch(url);
        };

        runner.group('GitVisualizer', () => {
            runner.test('Se registra como custom element', async () => {
                await runner.waitForElement('git-visualizer');
                runner.assertTrue(customElements.get('git-visualizer'));
            });

            runner.test('Renderiza estructura compuesta (Viewport > Layout)', async (stage) => {
                await runner.waitForElement('git-visualizer');
                const el = document.createElement('git-visualizer');
                stage.appendChild(el);
                
                // Esperar a connectedCallback (que hace el render de graph-viewport y proyecciÃ³n manual)
                // Esto es asÃ­ncrono y complejo porque hay promesas anidadas de fetch y updates
                await runner.sleep(100);

                const viewport = el.querySelector('graph-viewport');
                runner.assertTrue(viewport, 'Debe contener graph-viewport');
                
                // Verificar que node-graph estÃ¡ DENTRO del transform-layer del viewport
                // gracias a la proyecciÃ³n manual que arreglamos
                const transformLayer = viewport.querySelector('#transform-layer');
                const layout = transformLayer ? transformLayer.querySelector('node-graph') : null;
                
                runner.assertTrue(layout, 'node-graph debe estar proyectado dentro del transform-layer');
            });

            runner.test('Carga datos y oculta loader', async (stage) => {
                await runner.waitForElement('git-visualizer');
                const el = document.createElement('git-visualizer');
                stage.appendChild(el);
                
                const loader = el.querySelector('#loading');
                runner.assertTrue(loader, 'Loader debe existir inicialmente');
                
                await runner.sleep(200); // Esperar fetch mockeado
                
                runner.assertTrue(loader.classList.contains('opacity-0'), 'Loader debe ocultarse tras cargar');
                
                // Verificar datos en layout
                const layout = el.querySelector('node-graph');
                runner.assertTrue(layout.data, 'El layout debe tener datos asignados');
                runner.assertEqual(layout.data.data.label, 'root', 'El root debe ser correcto');
            });

            runner.test('Toggle View: switch entre Graph y Treemap', async (stage) => {
                await runner.waitForElement('git-visualizer');
                const el = document.createElement('git-visualizer');
                stage.appendChild(el);
                
                await runner.sleep(50); // wait init

                // Busca boton de toggle (asumiremos que tiene id o data-ref)
                // Vamos a mockear la existencia del botÃ³n si aÃºn no estÃ¡ en el cÃ³digo
                // Pero como es TDD, el test fallarÃ¡ primero.
                const toggleBtn = el.querySelector('#view-toggle');
                runner.assertTrue(toggleBtn, 'Debe existir botÃ³n de toggle de vista');
                
                // Estado inicial: Graph
                runner.assertTrue(el.querySelector('node-graph'), 'Inicialmente debe ser Node Graph');
                runner.assertFalse(el.querySelector('treemap-layout'), 'Inicialmente NO debe estar Treemap');
                
                // Click -> Treemap
                toggleBtn.click();
                await runner.sleep(10);
                
                runner.assertFalse(el.querySelector('node-graph'), 'Tras toggle, Node Graph debe desaparecer');
                runner.assertTrue(el.querySelector('treemap-layout'), 'Tras toggle, Treemap debe aparecer');
                
                // Click -> Graph
                toggleBtn.click();
                await runner.sleep(10);
                runner.assertTrue(el.querySelector('node-graph'), 'Debe volver a Node Graph');
            });

            runner.test('Metric Selector: visible solo en Treemap', async (stage) => {
                await runner.waitForElement('git-visualizer');
                const el = document.createElement('git-visualizer');
                stage.appendChild(el);
                await runner.sleep(50);

                const controls = el.querySelector('#metric-controls');
                
                // Graph mode (default) -> Hidden
                runner.assertTrue(controls.classList.contains('hidden'), 'Debe estar oculto en Graph');
                
                // Switch to Treemap
                const mapBtn = el.querySelector('#view-treemap');
                mapBtn.click();
                await runner.sleep(10);
                
                // Treemap mode -> Visible
                runner.assertFalse(controls.classList.contains('hidden'), 'Debe estar visible en Treemap');
            });
        });

        runner.run();
    </script>
</body>
</html>
