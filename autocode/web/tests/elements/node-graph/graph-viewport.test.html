<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Viewport - Unit Tests</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="p-8 bg-gray-100 min-h-screen">
    <div class="flex items-center gap-4 mb-2">
        <a href="/tests" class="text-indigo-600 hover:text-indigo-800">‚Üê Tests</a>
        <h1 class="text-3xl font-bold">üîç Graph Viewport - Unit Tests</h1>
    </div>

    <div id="summary" class="mb-6 p-4 bg-white rounded-lg shadow"></div>
    <div id="results" class="space-y-2"></div>

    <script type="module">
        import { TestRunner } from '../../utils/test-runner.js';

        try {
            await import('/elements/node-graph/graph-viewport.js');
        } catch (e) {
            console.warn('graph-viewport.js no encontrado:', e.message);
        }

        const runner = new TestRunner();

        runner.group('GraphViewport', () => {
            runner.test('Se registra como custom element', async () => {
                await runner.waitForElement('graph-viewport');
                runner.assertTrue(customElements.get('graph-viewport'));
            });

            runner.test('Proyecci√≥n Manual: Renderiza contenido hijo en #transform-layer', async (stage) => {
                await runner.waitForElement('graph-viewport');
                const el = document.createElement('graph-viewport');
                
                // Inyectamos contenido declarativo ANTES de connectedCallback (que ocurre al hacer appendChild)
                el.innerHTML = `<div id="test-content">TEST CONTENT</div>`;
                
                stage.appendChild(el);
                await runner.sleep(50);

                // Verificamos que #test-content ahora vive dentro de #transform-layer
                const transformLayer = el.querySelector('#transform-layer');
                const injectedContent = transformLayer.querySelector('#test-content');
                
                runner.assertTrue(transformLayer, 'Debe existir transform-layer');
                runner.assertTrue(injectedContent, 'El contenido hijo debe moverse al transform-layer');
            });

            runner.test('Renderiza controles de UI (Zoom, Fit)', async (stage) => {
                await runner.waitForElement('graph-viewport');
                const el = document.createElement('graph-viewport');
                stage.appendChild(el);
                
                await runner.sleep(10);
                
                const btnFit = el.querySelector('#btn-fit');
                const btnZoomIn = el.querySelector('#btn-zoom-in');
                const btnZoomOut = el.querySelector('#btn-zoom-out');
                
                runner.assertTrue(btnFit, 'Bot√≥n Fit debe existir');
                runner.assertTrue(btnZoomIn, 'Bot√≥n Zoom In debe existir');
                runner.assertTrue(btnZoomOut, 'Bot√≥n Zoom Out debe existir');
            });

            runner.test('Interacci√≥n: Pan cambia transformaci√≥n CSS', async (stage) => {
                await runner.waitForElement('graph-viewport');
                const el = document.createElement('graph-viewport');
                // Dar tama√±o para poder hacer drag
                el.style.width = '500px';
                el.style.height = '500px';
                el.style.position = 'absolute';
                stage.appendChild(el);
                
                await runner.sleep(20);
                const container = el.querySelector('#viewport-container');
                const layer = el.querySelector('#transform-layer');
                
                // Simular Drag
                // Mousedown at 100,100
                container.dispatchEvent(new MouseEvent('mousedown', { clientX: 100, clientY: 100, bubbles: true }));
                
                // Mousemove to 200, 200 (Delta +100, +100)
                window.dispatchEvent(new MouseEvent('mousemove', { clientX: 200, clientY: 200, bubbles: true }));
                
                await runner.sleep(10);
                
                // Verificar transform
                // Initial es 0,0 (o fit center).
                // Chequeamos que transform NO est√© vac√≠a y haya cambiado.
                // Como es dif√≠cil predecir el valor exacto por el fitToScreen inicial, 
                // verificamos que contenga translate.
                runner.assertTrue(layer.style.transform.includes('translate'), 'Debe aplicar translate');
                
                // Mouseup
                window.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
            });
        });

        runner.run();
    </script>
</body>
</html>
