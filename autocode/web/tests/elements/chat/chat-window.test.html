<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Window - Unit Tests</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="p-8 bg-gray-100 min-h-screen">
    <div class="flex items-center gap-4 mb-2">
        <a href="/tests" class="text-indigo-600 hover:text-indigo-800">‚Üê Tests</a>
        <h1 class="text-3xl font-bold">ü™ü Chat Window - Unit Tests</h1>
    </div>
    
    <div id="summary" class="mb-6 p-4 bg-white rounded-lg shadow"></div>
    <div id="results" class="space-y-2"></div>

    <script type="module">
        import { TestRunner } from '../../utils/test-runner.js'; 
        
        try {
            await import('/elements/chat/chat-window.js');
        } catch (e) {
            console.warn('chat-window.js no encontrado:', e.message);
        }
        
        // Dependencias (necesarias para tests de proyecci√≥n de slots)
        try { await import('/elements/chat/chat-input.js'); } catch {}
        try { await import('/elements/chat/chat-messages.js'); } catch {}

        const runner = new TestRunner();

        runner.group('ChatWindow', () => {
            runner.test('ChatWindow: se registra como custom element', async () => {
                await runner.waitForElement('chat-window');
                runner.assertTrue(customElements.get('chat-window'));
            });

            runner.test('ChatWindow: tiene shadowRoot', async (stage) => {
                await runner.waitForElement('chat-window');
                const el = document.createElement('chat-window');
                stage.appendChild(el);
                
                runner.assertTrue(el.shadowRoot, 'Debe tener shadowRoot');
            });

            runner.test('ChatWindow: toggle abre/cierra ventana', async (stage) => {
                await runner.waitForElement('chat-window');
                const el = document.createElement('chat-window');
                stage.appendChild(el);
                
                const panel = el.shadowRoot.querySelector('[data-ref="panel"]');
                
                runner.assertTrue(panel.classList.contains('hidden'), 'Debe empezar cerrado');
                
                el.toggle();
                runner.assertFalse(panel.classList.contains('hidden'), 'Debe abrirse con toggle');
                
                el.toggle();
                runner.assertTrue(panel.classList.contains('hidden'), 'Debe cerrarse con toggle');
            });

            runner.test('ChatWindow: open/close m√©todos funcionan', async (stage) => {
                await runner.waitForElement('chat-window');
                const el = document.createElement('chat-window');
                stage.appendChild(el);
                
                const panel = el.shadowRoot.querySelector('[data-ref="panel"]');
                
                el.open();
                runner.assertFalse(panel.classList.contains('hidden'), 'open() debe abrir');
                
                el.close();
                runner.assertTrue(panel.classList.contains('hidden'), 'close() debe cerrar');
            });

            runner.test('ChatWindow: emite evento close al cerrar', async (stage) => {
                await runner.waitForElement('chat-window');
                const el = document.createElement('chat-window');
                stage.appendChild(el);
                
                let closeEmitted = false;
                el.addEventListener('close', () => closeEmitted = true);
                
                el.open();
                el.close();
                
                runner.assertTrue(closeEmitted, 'Debe emitir evento close');
            });

            runner.test('ChatWindow: title configurable via atributo', async (stage) => {
                await runner.waitForElement('chat-window');
                const el = document.createElement('chat-window');
                el.setAttribute('title', 'Mi Chat');
                stage.appendChild(el);
                
                const title = el.shadowRoot.querySelector('[data-ref="title"]');
                runner.assertTrue(title.textContent.includes('Mi Chat'));
            });

            runner.test('ChatWindow: acepta elementos hijos con atributos slot', async (stage) => {
                await runner.waitForElement('chat-window');
                const el = document.createElement('chat-window');
                el.innerHTML = `
                    <span slot="header-actions">Custom Action</span>
                    <div slot="content">Custom Content</div>
                    <div slot="footer">Custom Footer</div>
                `;
                stage.appendChild(el);
                
                // En Light DOM, los elementos con slot existen como hijos del host
                runner.assertTrue(el.querySelector('[slot="content"]'), 'Debe contener elemento con slot content');
                runner.assertTrue(el.querySelector('[slot="header-actions"]'), 'Debe contener elemento con slot header-actions');
                runner.assertTrue(el.querySelector('[slot="footer"]'), 'Debe contener elemento con slot footer');
            });

            runner.test('ChatWindow: preserva contenido slotted despu√©s de render', async (stage) => {
                await runner.waitForElement('chat-window');
                const el = document.createElement('chat-window');
                
                el.innerHTML = `
                    <button slot="header-actions">Test Action</button>
                    <div slot="content" data-test="content">Content Area</div>
                    <div slot="footer" data-test="footer">
                        <input type="text" placeholder="Test input">
                    </div>
                `;
                
                stage.appendChild(el);
                
                // Esperar a que connectedCallback termine
                await runner.sleep(50);
                
                // El contenido slotted debe existir y ser accesible
                const footerContent = el.querySelector('[data-test="footer"]');
                const inputInFooter = el.querySelector('[slot="footer"] input');
                
                runner.assertTrue(footerContent, 'El footer slotted debe existir despu√©s del render');
                runner.assertTrue(inputInFooter, 'El input dentro del footer slot debe existir');
            });

            runner.test('ChatWindow: slots proyectan contenido correctamente', async (stage) => {
                await runner.waitForElement('chat-window');
                const el = document.createElement('chat-window');
                el.innerHTML = `
                    <span slot="header-actions">Custom Button</span>
                    <chat-messages slot="content"></chat-messages>
                    <div slot="footer">
                        <chat-input placeholder="Test"></chat-input>
                    </div>
                `;
                
                stage.appendChild(el);
                el.open();
                
                await runner.sleep(50);
                
                // Verificar que chat-input est√° visible y funcional
                const chatInput = el.querySelector('chat-input');
                runner.assertTrue(chatInput, 'chat-input debe existir en el slot footer');
                
                // Verificar que el input interno existe
                const input = chatInput?.querySelector('input');
                // Nota: chat-input puede tardar en renderizar su shadow DOM
                // pero su light DOM (el tag <chat-input>) ya est√° ah√≠.
                // Si chat-input usa shadowDOM, 'input' estar√° en su shadowRoot.
                if (chatInput.shadowRoot) {
                     const shadowInput = chatInput.shadowRoot.querySelector('input');
                     runner.assertTrue(shadowInput, 'El input interno de chat-input (shadow) debe existir');
                } else {
                     runner.assertTrue(input, 'El input interno de chat-input (light) debe existir');
                }
            });
        });

        runner.run();
    </script>
</body>
</html>
