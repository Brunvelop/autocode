<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Messages - Unit Tests</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="p-8 bg-gray-100 min-h-screen">
    <div class="flex items-center gap-4 mb-2">
        <a href="/tests" class="text-indigo-600 hover:text-indigo-800">â† Tests</a>
        <h1 class="text-3xl font-bold">ğŸ’¬ Chat Messages - Unit Tests</h1>
    </div>
    
    <div id="summary" class="mb-6 p-4 bg-white rounded-lg shadow"></div>
    <div id="results" class="space-y-2"></div>

    <script type="module">
        import { TestRunner } from '../../utils/test-runner.js'; 
        
        import '/elements/chat/chat-messages.js';

        const runner = new TestRunner();

        runner.group('ChatMessages', () => {
            // ========================================
            // TEST 1: Registro del Custom Element
            // ========================================
            runner.test('ChatMessages: se registra como custom element', async () => {
                await runner.waitForElement('chat-messages');
                runner.assertTrue(customElements.get('chat-messages'));
            });

            // ========================================
            // TEST 2: API addMessage() - Usuario
            // ========================================
            runner.test('ChatMessages: addMessage() aÃ±ade mensaje de usuario', async (stage) => {
                const el = document.createElement('chat-messages');
                stage.appendChild(el);
                await el.updateComplete;
                
                el.addMessage('user', 'Hola mundo');
                await el.updateComplete;
                
                // Verificar usando la API pÃºblica
                const messages = el.getMessages();
                runner.assertEqual(messages.length, 1, 'Debe tener 1 mensaje');
                runner.assertEqual(messages[0].role, 'user', 'Rol debe ser user');
                runner.assertEqual(messages[0].content, 'Hola mundo', 'Contenido debe coincidir');
                
                // Verificar renderizaciÃ³n en Shadow DOM
                const userMessages = el.shadowRoot.querySelectorAll('[data-role="user"]');
                runner.assertEqual(userMessages.length, 1, 'Debe renderizar 1 mensaje de usuario');
                runner.assertTrue(userMessages[0].textContent.includes('Hola mundo'), 'Debe contener el texto');
            });

            // ========================================
            // TEST 3: API addMessage() - Asistente
            // ========================================
            runner.test('ChatMessages: addMessage() aÃ±ade mensaje de asistente', async (stage) => {
                const el = document.createElement('chat-messages');
                stage.appendChild(el);
                await el.updateComplete;
                
                el.addMessage('assistant', 'Respuesta AI');
                await el.updateComplete;
                
                const messages = el.getMessages();
                runner.assertEqual(messages.length, 1);
                runner.assertEqual(messages[0].role, 'assistant');
                
                const assistantMessages = el.shadowRoot.querySelectorAll('[data-role="assistant"]');
                runner.assertEqual(assistantMessages.length, 1);
                runner.assertTrue(assistantMessages[0].textContent.includes('Respuesta AI'));
            });

            // ========================================
            // TEST 4: API addMessage() - Error
            // ========================================
            runner.test('ChatMessages: addMessage() aÃ±ade mensaje de error', async (stage) => {
                const el = document.createElement('chat-messages');
                stage.appendChild(el);
                await el.updateComplete;
                
                el.addMessage('error', 'Algo saliÃ³ mal');
                await el.updateComplete;
                
                const messages = el.getMessages();
                runner.assertEqual(messages.length, 1);
                runner.assertEqual(messages[0].role, 'error');
                
                const errorMessages = el.shadowRoot.querySelectorAll('[data-role="error"]');
                runner.assertEqual(errorMessages.length, 1);
            });

            // ========================================
            // TEST 5: API clear()
            // ========================================
            runner.test('ChatMessages: clear() elimina todos los mensajes', async (stage) => {
                const el = document.createElement('chat-messages');
                stage.appendChild(el);
                await el.updateComplete;
                
                el.addMessage('user', 'Mensaje 1');
                el.addMessage('assistant', 'Mensaje 2');
                el.addMessage('error', 'Mensaje 3');
                await el.updateComplete;
                
                runner.assertEqual(el.getMessages().length, 3, 'Debe tener 3 mensajes antes de clear');
                
                el.clear();
                await el.updateComplete;
                
                runner.assertEqual(el.getMessages().length, 0, 'Debe tener 0 mensajes despuÃ©s de clear');
                
                const allMessages = el.shadowRoot.querySelectorAll('[data-role]');
                runner.assertEqual(allMessages.length, 0, 'No debe haber mensajes renderizados');
            });

            // ========================================
            // TEST 6: API getMessages()
            // ========================================
            runner.test('ChatMessages: getMessages() retorna array de mensajes', async (stage) => {
                const el = document.createElement('chat-messages');
                stage.appendChild(el);
                await el.updateComplete;
                
                el.addMessage('user', 'Msg 1');
                el.addMessage('assistant', 'Msg 2');
                await el.updateComplete;
                
                const messages = el.getMessages();
                
                runner.assertTrue(Array.isArray(messages), 'Debe retornar un array');
                runner.assertEqual(messages.length, 2, 'Debe tener 2 mensajes');
                runner.assertTrue('timestamp' in messages[0], 'Cada mensaje debe tener timestamp');
            });

            // ========================================
            // TEST 7: MÃºltiples mensajes
            // ========================================
            runner.test('ChatMessages: maneja mÃºltiples mensajes correctamente', async (stage) => {
                const el = document.createElement('chat-messages');
                stage.appendChild(el);
                await el.updateComplete;
                
                el.addMessage('user', 'Pregunta 1');
                el.addMessage('assistant', 'Respuesta 1');
                el.addMessage('user', 'Pregunta 2');
                el.addMessage('assistant', 'Respuesta 2');
                await el.updateComplete;
                
                const messages = el.getMessages();
                runner.assertEqual(messages.length, 4);
                
                // Verificar orden
                runner.assertEqual(messages[0].content, 'Pregunta 1');
                runner.assertEqual(messages[1].content, 'Respuesta 1');
                runner.assertEqual(messages[2].content, 'Pregunta 2');
                runner.assertEqual(messages[3].content, 'Respuesta 2');
            });

            // ========================================
            // TEST 8: Objeto complejo con reasoning
            // ========================================
            runner.test('ChatMessages: soporta objeto complejo con reasoning', async (stage) => {
                const el = document.createElement('chat-messages');
                stage.appendChild(el);
                await el.updateComplete;
                
                const complexResponse = {
                    result: 'Respuesta final',
                    reasoning: 'Paso 1: Analizar\nPaso 2: Pensar\nPaso 3: Responder'
                };
                
                el.addMessage('assistant', complexResponse);
                await el.updateComplete;
                
                // Verificar que se renderiza el reasoning
                const reasoningEl = el.shadowRoot.querySelector('[data-type="reasoning"]');
                runner.assertTrue(reasoningEl, 'Debe existir el elemento de reasoning');
                runner.assertTrue(reasoningEl.textContent.includes('Paso 1'), 'Debe contener el texto del reasoning');
            });

            // ========================================
            // TEST 9: Objeto complejo con trajectory
            // ========================================
            runner.test('ChatMessages: soporta objeto complejo con trajectory', async (stage) => {
                const el = document.createElement('chat-messages');
                stage.appendChild(el);
                await el.updateComplete;
                
                const complexResponse = {
                    result: 'Respuesta final',
                    trajectory: [
                        { 
                            thought: 'Necesito buscar informaciÃ³n', 
                            tool_name: 'search_tool', 
                            tool_input: '{"query": "test"}', 
                            observation: 'Resultado encontrado' 
                        }
                    ]
                };
                
                el.addMessage('assistant', complexResponse);
                await el.updateComplete;
                
                // Buscar el nombre de la herramienta en el contenido renderizado
                const content = el.shadowRoot.textContent;
                runner.assertTrue(content.includes('search_tool'), 'Debe mostrar nombre de herramienta');
                runner.assertTrue(content.includes('Necesito buscar informaciÃ³n'), 'Debe mostrar pensamiento');
            });

            // ========================================
            // TEST 10: Objeto con result anidado
            // ========================================
            runner.test('ChatMessages: extrae texto de objetos result anidados', async (stage) => {
                const el = document.createElement('chat-messages');
                stage.appendChild(el);
                await el.updateComplete;
                
                const nestedResponse = {
                    result: {
                        response: 'Texto de respuesta anidado'
                    }
                };
                
                el.addMessage('assistant', nestedResponse);
                await el.updateComplete;
                
                const content = el.shadowRoot.textContent;
                runner.assertTrue(content.includes('Texto de respuesta anidado'), 'Debe extraer texto anidado');
            });

            // ========================================
            // TEST 11: Estado inicial vacÃ­o
            // ========================================
            runner.test('ChatMessages: muestra estado vacÃ­o cuando no hay mensajes', async (stage) => {
                const el = document.createElement('chat-messages');
                stage.appendChild(el);
                await el.updateComplete;
                
                const emptyState = el.shadowRoot.querySelector('.empty-state');
                runner.assertTrue(emptyState, 'Debe mostrar estado vacÃ­o');
                runner.assertTrue(emptyState.textContent.includes('conversaciÃ³n'), 'Debe tener texto de prompt');
            });

            // ========================================
            // TEST 12: Auto-scroll tras aÃ±adir mensaje
            // ========================================
            runner.test('ChatMessages: auto-scroll al aÃ±adir mensaje', async (stage) => {
                const el = document.createElement('chat-messages');
                el.style.height = '200px';
                stage.appendChild(el);
                await el.updateComplete;
                
                // AÃ±adir muchos mensajes para forzar scroll
                for (let i = 0; i < 20; i++) {
                    el.addMessage('user', `Mensaje largo nÃºmero ${i} con contenido extenso para ocupar espacio vertical`);
                }
                
                await el.updateComplete;
                await runner.sleep(100);
                
                // Verificar que el container interno tiene scroll
                const container = el.shadowRoot.querySelector('#container');
                runner.assertTrue(container.scrollHeight > container.clientHeight, 'Debe tener contenido scrolleable');
                
                // El scroll debe estar al final (con pequeÃ±o margen de error)
                const scrollDiff = container.scrollHeight - container.scrollTop - container.clientHeight;
                runner.assertTrue(scrollDiff < 10, 'Debe estar scrolleado al final (diff < 10px)');
            });
        });

        runner.run();
    </script>
</body>
</html>
