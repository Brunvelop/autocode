{
  "timestamp": "2025-07-17T07:59:40.175710",
  "project_name": "Autocode - Documentación Técnica",
  "config": {
    "output_path": ".clinerules\\docs_index.json",
    "generated_by": "autocode-doc-indexer",
    "version": "1.0.0"
  },
  "documentation_stats": {
    "total_files": 39,
    "total_modules": 25,
    "total_directories": 24,
    "total_purposes_found": 64
  },
  "structure": {
    "docs/": {
      "type": "module",
      "index_file": "docs\\_index.md",
      "purpose": "El módulo autocode proporciona herramientas automatizadas para la calidad del código y el desarrollo del proyecto Vidi. Su responsabilidad principal es automatizar tareas de mantenimiento como la verificación de documentación, el análisis de cambios en git, y la integración con OpenCode AI para análisis inteligente de código, incluyendo tanto herramientas CLI como un sistema de monitoreo continuo con interfaz web.",
      "last_modified": "2025-07-08T13:38:30.956838",
      "module_file": "docs\\_module.md",
      "subdirectories": {
        "docs\\autocode/": {
          "type": "module",
          "module_file": "docs\\autocode\\_module.md",
          "purpose": "autocode es el módulo raíz que contiene toda la lógica de la aplicación. Su propósito es proporcionar una plataforma integrada que combina la verificación de documentación, el análisis de cambios en Git, la validación de tests y un sistema de monitoreo en tiempo real, todo a través de una arquitectura modular y extensible.",
          "last_modified": "2025-07-17T07:45:42.882911",
          "subdirectories": {
            "docs\\autocode\\api/": {
              "type": "module",
              "module_file": "docs\\autocode\\api\\_module.md",
              "purpose": "Este módulo proporciona la interfaz web y la API RESTful para el sistema autocode. Su responsabilidad principal es ofrecer un dashboard en tiempo real para monitorear el estado del sistema y una API programática para la integración con otras herramientas y flujos de trabajo.",
              "last_modified": "2025-07-17T07:59:12.370469",
              "files": {
                "docs\\autocode\\api\\models.md": {
                  "type": "file_doc",
                  "purpose": "Este módulo define todos los modelos de datos utilizados por la API de autocode, tanto para la configuración del sistema como para las respuestas de los endpoints. Utiliza Pydantic para definir esquemas de datos tipados, lo que garantiza la validación automática, la serialización y deserialización de JSON, y una documentación clara de la API (a través de OpenAPI/Swagger).",
                  "last_modified": "2025-07-16T17:13:05.342727"
                },
                "docs\\autocode\\api\\server.md": {
                  "type": "file_doc",
                  "purpose": "Este módulo implementa el servidor web y la API RESTful para el sistema de monitoreo en tiempo real de autocode. Utiliza FastAPI para proporcionar una interfaz web (dashboard) y una serie de endpoints programáticos para interactuar con el AutocodeDaemon.",
                  "last_modified": "2025-07-17T07:54:35.551528"
                }
              }
            },
            "docs\\autocode\\core/": {
              "type": "module",
              "module_file": "docs\\autocode\\core\\_module.md",
              "purpose": "El módulo core contiene la lógica de negocio y las funcionalidades fundamentales del sistema autocode. Su responsabilidad es proporcionar todos los componentes necesarios para el análisis y la verificación automatizada del código, la documentación y los tests de un proyecto.",
              "last_modified": "2025-07-17T07:45:29.143672",
              "subdirectories": {
                "docs\\autocode\\core\\ai/": {
                  "type": "module",
                  "module_file": "docs\\autocode\\core\\ai\\_module.md",
                  "purpose": "Este módulo agrupa las funcionalidades relacionadas con la interacción con modelos de lenguaje grandes (LLM) y herramientas de inteligencia artificial. Su propósito es abstraer la complejidad de estas interacciones, proporcionando una interfaz sencilla para tareas como la ejecución de análisis de código con IA y el conteo de tokens.",
                  "last_modified": "2025-07-16T17:08:30.532067",
                  "files": {
                    "docs\\autocode\\core\\ai\\opencode_executor.md": {
                      "type": "file_doc",
                      "purpose": "Proporciona una interfaz para ejecutar análisis de OpenCode de forma programática y en modo \"headless\" (sin interfaz gráfica), gestionando la configuración, la ejecución de comandos y el formato de los resultados para su uso en flujos de trabajo automatizados.",
                      "last_modified": "2025-07-16T16:56:24.170988"
                    },
                    "docs\\autocode\\core\\ai\\token_counter.md": {
                      "type": "file_doc",
                      "purpose": "Proporciona una herramienta para contar la cantidad de tokens en textos y archivos, utilizando las codificaciones de modelos de lenguaje grandes (LLM) a través de la biblioteca tiktoken. Es esencial para estimar costos de API, validar límites de contexto y analizar el uso de tokens en aplicaciones de IA.",
                      "last_modified": "2025-07-16T16:56:49.130703"
                    }
                  }
                },
                "docs\\autocode\\core\\design/": {
                  "type": "module",
                  "module_file": "docs\\autocode\\core\\design\\_module.md",
                  "purpose": "El módulo design es un sistema completo para la generación automática de documentación de diseño a partir del código fuente. Su propósito es analizar un proyecto, entender su estructura y componentes, y producir una serie de documentos Markdown con diagramas que describen la arquitectura del software de manera visual y estructurada.",
                  "last_modified": "2025-07-17T07:59:32.291460",
                  "subdirectories": {
                    "docs\\autocode\\core\\design\\analyzers/": {
                      "type": "module",
                      "module_file": "docs\\autocode\\core\\design\\analyzers\\_module.md",
                      "purpose": "Este módulo es el corazón del sistema de análisis de código. Su propósito es proporcionar un framework extensible para analizar diferentes lenguajes de programación y extraer su estructura en un formato de datos estandarizado. Contiene la lógica para la creación dinámica de analizadores y las implementaciones concretas para cada lenguaje.",
                      "last_modified": "2025-07-16T17:09:54.306837",
                      "subdirectories": {
                        "docs\\autocode\\core\\design\\analyzers\\javascript/": {
                          "type": "module",
                          "module_file": "docs\\autocode\\core\\design\\analyzers\\javascript\\_module.md",
                          "purpose": "Este módulo contiene el analizador de código especializado para JavaScript y TypeScript. Su propósito es implementar la lógica para parsear archivos de frontend (.js, .ts, .jsx, .tsx) y extraer una representación estructurada de su contenido, como clases, funciones y módulos ES6.",
                          "last_modified": "2025-07-16T17:09:07.416059",
                          "files": {
                            "docs\\autocode\\core\\design\\analyzers\\javascript\\analyzer.md": {
                              "type": "file_doc",
                              "purpose": "JavaScriptAnalyzer es una implementación de BaseAnalyzer diseñada para analizar código fuente de JavaScript y TypeScript. Su objetivo es extraer información estructural clave, como clases, funciones, imports y exports, para alimentar el sistema de generación de documentación de diseño.",
                              "last_modified": "2025-07-16T17:05:43.431071"
                            }
                          }
                        },
                        "docs\\autocode\\core\\design\\analyzers\\python/": {
                          "type": "module",
                          "module_file": "docs\\autocode\\core\\design\\analyzers\\python\\_module.md",
                          "purpose": "Este módulo contiene el analizador de código especializado para Python. Su único propósito es implementar la lógica necesaria para parsear archivos de código fuente de Python (.py y .pyi) y extraer una representación estructurada de su contenido.",
                          "last_modified": "2025-07-16T17:08:48.509803",
                          "files": {
                            "docs\\autocode\\core\\design\\analyzers\\python\\analyzer.md": {
                              "type": "file_doc",
                              "purpose": "PythonAnalyzer es una implementación robusta de BaseAnalyzer para analizar código fuente de Python. A diferencia del analizador de JavaScript, este utiliza el módulo ast (Abstract Syntax Tree) de Python, lo que le permite realizar un análisis mucho más preciso y detallado de la estructura del código. Su objetivo es extraer información sobre clases, funciones, imports y atributos para la generación de documentación de diseño.",
                              "last_modified": "2025-07-16T17:06:21.456620"
                            }
                          }
                        },
                        "docs\\autocode\\core\\design\\analyzers\\web/": {
                          "type": "module",
                          "module_file": "docs\\autocode\\core\\design\\analyzers\\web\\_module.md",
                          "purpose": "Este módulo contiene los analizadores especializados en extraer información de tecnologías web estándar (HTML y CSS). Su propósito es proporcionar los datos necesarios para entender la estructura y el estilo de las interfaces de usuario.",
                          "last_modified": "2025-07-16T17:08:10.023117",
                          "files": {
                            "docs\\autocode\\core\\design\\analyzers\\web\\css_analyzer.md": {
                              "type": "file_doc",
                              "purpose": "CSSAnalyzer es una implementación de BaseAnalyzer para analizar archivos de hojas de estilo (CSS, SCSS, etc.). Su objetivo es extraer información detallada sobre las reglas de estilo, selectores, propiedades, media queries y variables (custom properties) para proporcionar una visión completa del sistema de diseño de un proyecto.",
                              "last_modified": "2025-07-16T17:06:50.290554"
                            },
                            "docs\\autocode\\core\\design\\analyzers\\web\\html_analyzer.md": {
                              "type": "file_doc",
                              "purpose": "HTMLAnalyzer es una implementación de BaseAnalyzer para analizar archivos HTML. Su objetivo es parsear la estructura del DOM (Document Object Model) para extraer información sobre los elementos, componentes personalizados (custom elements), formularios, scripts y enlaces. Esto es fundamental para entender la estructura de una interfaz de usuario.",
                              "last_modified": "2025-07-16T17:07:18.265582"
                            }
                          }
                        }
                      },
                      "files": {
                        "docs\\autocode\\core\\design\\analyzers\\analyzer_factory.md": {
                          "type": "file_doc",
                          "purpose": "AnalyzerFactory es un componente central del sistema de diseño que se encarga de la creación dinámica de instancias de analizadores de código. Utiliza el patrón de diseño Factory y un Registro (Registry) para desacoplar el orquestador principal (CodeToDesign) de las implementaciones concretas de los analizadores (como PythonAnalyzer, JavaScriptAnalyzer, etc.). Esto hace que el sistema sea extensible y fácil de mantener.",
                          "last_modified": "2025-07-16T16:59:36.677124"
                        },
                        "docs\\autocode\\core\\design\\analyzers\\base_analyzer.md": {
                          "type": "file_doc",
                          "purpose": "BaseAnalyzer es una clase base abstracta que define el contrato o la interfaz que todos los analizadores de código específicos (como PythonAnalyzer, JavaScriptAnalyzer, etc.) deben seguir. Su propósito es garantizar que todos los analizadores tengan una estructura y un comportamiento consistentes, permitiendo que el sistema de diseño los trate de manera uniforme.",
                          "last_modified": "2025-07-16T17:00:01.674429"
                        }
                      }
                    },
                    "docs\\autocode\\core\\design\\diagrams/": {
                      "type": "module",
                      "module_file": "docs\\autocode\\core\\design\\diagrams\\_module.md",
                      "purpose": "Este módulo es responsable de generar representaciones visuales del código analizado. Contiene un framework extensible para crear diferentes tipos de diagramas (como diagramas de clases o de componentes) en varios formatos (actualmente Mermaid).",
                      "last_modified": "2025-07-16T17:11:41.626988",
                      "files": {
                        "docs\\autocode\\core\\design\\diagrams\\base_generator.md": {
                          "type": "file_doc",
                          "purpose": "BaseGenerator es una clase base abstracta que establece el contrato para todos los generadores de diagramas del sistema. Su función es asegurar que cualquier generador (ya sea para Mermaid, PlantUML, etc.) se integre de manera consistente en el flujo de trabajo de CodeToDesign, proporcionando una interfaz común para la creación de diagramas.",
                          "last_modified": "2025-07-16T17:00:26.778716"
                        },
                        "docs\\autocode\\core\\design\\diagrams\\class_diagram_generator.md": {
                          "type": "file_doc",
                          "purpose": "ClassDiagramGenerator es una implementación concreta de BaseGenerator especializada en crear diagramas de clases utilizando la sintaxis de Mermaid. Su única responsabilidad es tomar una estructura de datos que representa una clase de Python y traducirla a un diagrama de texto que puede ser renderizado por Mermaid.",
                          "last_modified": "2025-07-16T17:00:52.626514"
                        },
                        "docs\\autocode\\core\\design\\diagrams\\component_tree_generator.md": {
                          "type": "file_doc",
                          "purpose": "ComponentTreeGenerator es una implementación de BaseGenerator diseñada para visualizar la arquitectura de interfaces de usuario (UI). Su responsabilidad es tomar los datos de análisis de componentes de UI (provenientes de analizadores como JavaScriptAnalyzer o HTMLAnalyzer) y generar un diagrama de árbol de componentes en formato Mermaid.",
                          "last_modified": "2025-07-16T17:01:18.078655"
                        },
                        "docs\\autocode\\core\\design\\diagrams\\generator_factory.md": {
                          "type": "file_doc",
                          "purpose": "GeneratorFactory es una factoría, análoga a AnalyzerFactory, responsable de crear dinámicamente instancias de generadores de diagramas. Su función es desacoplar el sistema de las implementaciones concretas de los generadores (como ClassDiagramGenerator), permitiendo una fácil extensión para soportar nuevos formatos de diagramas (ej. PlantUML, D2) en el futuro.",
                          "last_modified": "2025-07-16T17:01:43.096488"
                        },
                        "docs\\autocode\\core\\design\\diagrams\\markdown_exporter.md": {
                          "type": "file_doc",
                          "purpose": "MarkdownExporter es el componente final en el pipeline de generación de diseño. Su responsabilidad es tomar los resultados estructurados del análisis de código y utilizar los generadores de diagramas para producir la documentación final en formato Markdown. Orquesta la creación de la estructura de directorios de salida y la escritura de cada archivo (_index.md, _module.md, *_items.md).",
                          "last_modified": "2025-07-16T17:02:14.059876"
                        }
                      }
                    },
                    "docs\\autocode\\core\\design\\utils/": {
                      "type": "module",
                      "module_file": "docs\\autocode\\core\\design\\utils\\_module.md",
                      "purpose": "Este módulo proporciona una colección de funciones de utilidad de propósito general para el sistema de generación de diseño. Su principal responsabilidad es manejar tareas de procesamiento de datos que son compartidas por otros componentes, como la transformación de estructuras de datos y el cálculo de métricas.",
                      "last_modified": "2025-07-16T17:10:56.061126",
                      "files": {
                        "docs\\autocode\\core\\design\\utils\\general_utils.md": {
                          "type": "file_doc",
                          "purpose": "GeneralUtils es una clase de utilidad que contiene lógica compartida y agnóstica al proyecto para procesar los datos de análisis. Su responsabilidad principal es transformar la estructura de datos \"plana\" que producen los analizadores en una estructura de árbol jerárquico y calcular métricas agregadas sobre ella.",
                          "last_modified": "2025-07-16T17:02:42.076023"
                        }
                      }
                    }
                  },
                  "files": {
                    "docs\\autocode\\core\\design\\code_to_design.md": {
                      "type": "file_doc",
                      "purpose": "Este módulo es el orquestador principal para transformar código fuente en documentación de diseño modular y visual. Su función es analizar un proyecto, extraer su estructura y componentes clave, y generar una serie de archivos Markdown que describen la arquitectura del software, incluyendo diagramas y métricas.",
                      "last_modified": "2025-07-17T07:55:03.799515"
                    }
                  }
                },
                "docs\\autocode\\core\\docs/": {
                  "type": "module",
                  "module_file": "docs\\autocode\\core\\docs\\_module.md",
                  "purpose": "Este módulo se centra en la meta-documentación: herramientas para analizar y gestionar la propia documentación del proyecto. Su propósito es asegurar que la documentación se mantenga actualizada, completa y sea fácilmente navegable.",
                  "last_modified": "2025-07-16T17:11:17.830261",
                  "files": {
                    "docs\\autocode\\core\\docs\\doc_checker.md": {
                      "type": "file_doc",
                      "purpose": "DocChecker es el componente central para verificar el estado de la documentación modular en un proyecto. Su responsabilidad principal es comparar las fechas de modificación entre los archivos de código fuente y sus correspondientes archivos de documentación, siguiendo una estructura jerárquica (_index.md, _module.md, archivo.md).",
                      "last_modified": "2025-07-16T16:57:44.728431"
                    },
                    "docs\\autocode\\core\\docs\\doc_indexer.md": {
                      "type": "file_doc",
                      "purpose": "DocIndexer es responsable de escanear la estructura de la documentación modular (docs/) y generar un índice JSON estructurado. Este índice actúa como un \"mapa\" de toda la documentación, extrayendo el propósito de cada archivo y módulo para facilitar la búsqueda, la navegación y el análisis programático del contenido documental.",
                      "last_modified": "2025-07-16T16:58:13.031611"
                    }
                  }
                },
                "docs\\autocode\\core\\git/": {
                  "type": "module",
                  "module_file": "docs\\autocode\\core\\git\\_module.md",
                  "purpose": "Este módulo encapsula toda la lógica para interactuar con el sistema de control de versiones Git. Su propósito principal es analizar el estado de un repositorio, identificar los cambios en los archivos y estructurar esa información para que pueda ser utilizada por otras herramientas, como generadores automáticos de mensajes de commit.",
                  "last_modified": "2025-07-16T17:09:29.533926",
                  "files": {
                    "docs\\autocode\\core\\git\\git_analyzer.md": {
                      "type": "file_doc",
                      "purpose": "GitAnalyzer es un componente diseñado para analizar el estado de un repositorio de Git. Su función principal es obtener una lista detallada de todos los cambios en los archivos (modificados, añadidos, eliminados, etc.), incluyendo los diffs específicos, y estructurar esta información en un formato JSON. Este resultado es ideal para alimentar herramientas automáticas, como generadores de mensajes de commit basados en IA.",
                      "last_modified": "2025-07-16T16:58:39.943033"
                    }
                  }
                },
                "docs\\autocode\\core\\test/": {
                  "type": "module",
                  "module_file": "docs\\autocode\\core\\test\\_module.md",
                  "purpose": "Este módulo se encarga de la verificación del estado de los tests del proyecto. Su responsabilidad es analizar la cobertura de tests siguiendo una estructura modular, identificar tests faltantes o huérfanos, y ejecutar los tests existentes para validar su estado.",
                  "last_modified": "2025-07-16T17:10:37.791250",
                  "files": {
                    "docs\\autocode\\core\\test\\test_checker.md": {
                      "type": "file_doc",
                      "purpose": "TestChecker es el componente responsable de verificar el estado de los tests en el proyecto, siguiendo una estructura modular. Su responsabilidad principal es detectar tests faltantes, validar tests existentes ejecutándolos, e identificar tests huérfanos que ya no corresponden a código fuente existente. Mapea automáticamente archivos de código a sus tests correspondientes pero no los crea, proporcionando información para que los desarrolladores mantengan una cobertura de tests adecuada.",
                      "last_modified": "2025-07-16T16:59:07.011275"
                    }
                  }
                }
              }
            },
            "docs\\autocode\\orchestration/": {
              "type": "module",
              "module_file": "docs\\autocode\\orchestration\\_module.md",
              "purpose": "Este módulo proporciona el sistema de automatización y programación para autocode. Su responsabilidad principal es orquestar la ejecución automática de las verificaciones, gestionar tareas programadas y proporcionar la base para el monitoreo continuo del sistema. Actúa como el cerebro que coordina todas las operaciones automatizadas.",
              "last_modified": "2025-07-16T17:18:15.708196",
              "files": {
                "docs\\autocode\\orchestration\\daemon.md": {
                  "type": "file_doc",
                  "purpose": "AutocodeDaemon es el orquestador central del sistema de monitoreo continuo. Su responsabilidad es ejecutar periódicamente las diferentes verificaciones (DocChecker, GitAnalyzer, TestChecker), mantener el estado de los resultados y proporcionar esta información a la API.",
                  "last_modified": "2025-07-16T17:14:08.947078"
                },
                "docs\\autocode\\orchestration\\scheduler.md": {
                  "type": "file_doc",
                  "purpose": "Sistema de programación de tareas periódicas que ejecuta funciones a intervalos regulares de forma asíncrona. Proporciona gestión dinámica de tareas, soporte para funciones síncronas y asíncronas, y manejo robusto de errores.",
                  "last_modified": "2025-07-09T14:00:02.390920"
                }
              }
            },
            "docs\\autocode\\web/": {
              "type": "module",
              "module_file": "docs\\autocode\\web\\_module.md",
              "purpose": "Este módulo contiene todos los componentes necesarios para construir y servir el frontend del dashboard de monitoreo de autocode. Su responsabilidad es proporcionar una interfaz de usuario web moderna e interactiva para la visualización en tiempo real del estado del sistema.",
              "last_modified": "2025-07-17T07:57:50.714234",
              "subdirectories": {
                "docs\\autocode\\web\\static/": {
                  "type": "module",
                  "module_file": "docs\\autocode\\web\\static\\_module.md",
                  "purpose": "Este módulo contiene todos los assets estáticos del frontend para la aplicación web autocode. Su responsabilidad es proporcionar los archivos (CSS y JavaScript) que son servidos directamente al navegador para definir la apariencia visual de la interfaz de usuario y dotarla de interactividad.",
                  "last_modified": "2025-07-17T07:53:27.293479",
                  "subdirectories": {
                    "docs\\autocode\\web\\static\\js/": {
                      "type": "module",
                      "module_file": "docs\\autocode\\web\\static\\js\\_module.md",
                      "purpose": "Este módulo contiene todo el código JavaScript del lado del cliente para la aplicación autocode. Su responsabilidad general es hacer que la interfaz web sea interactiva y dinámica, manejando la lógica de la aplicación en el navegador, la comunicación con el servidor y la manipulación del DOM.",
                      "last_modified": "2025-07-17T07:51:41.388201",
                      "subdirectories": {
                        "docs\\autocode\\web\\static\\js\\components/": {
                          "type": "module",
                          "module_file": "docs\\autocode\\web\\static\\js\\components\\_module.md",
                          "purpose": "Este módulo contiene los scripts de JavaScript que dotan de lógica y funcionalidad a los componentes de la interfaz de usuario (UI) de la aplicación autocode. Cada archivo en este directorio es responsable de controlar un componente HTML específico, manejando eventos de usuario, interactuando con la API y actualizando el DOM.",
                          "last_modified": "2025-07-17T07:51:05.013004",
                          "files": {
                            "docs\\autocode\\web\\static\\js\\components\\ui-designer.md": {
                              "type": "file_doc",
                              "purpose": "Este script gestiona un visor dinámico para la documentación de diseño del proyecto. Su función es obtener archivos de diseño (Markdown con diagramas Mermaid) desde una API, procesarlos y renderizarlos en el frontend, proporcionando una interfaz interactiva para explorar la arquitectura visual del sistema.",
                              "last_modified": "2025-07-17T07:46:43.590630"
                            }
                          }
                        },
                        "docs\\autocode\\web\\static\\js\\utils/": {
                          "type": "module",
                          "module_file": "docs\\autocode\\web\\static\\js\\utils\\_module.md",
                          "purpose": "Este módulo agrupa scripts de JavaScript que proporcionan funcionalidades de utilidad de propósito general, diseñadas para ser reutilizadas por otros componentes del frontend. Su objetivo es encapsular lógica común, como la comunicación con la API, para evitar la duplicación de código y facilitar el mantenimiento.",
                          "last_modified": "2025-07-17T07:51:23.172843",
                          "files": {
                            "docs\\autocode\\web\\static\\js\\utils\\api-fetch.md": {
                              "type": "file_doc",
                              "purpose": "Este script proporciona una clase APIClient que actúa como un cliente HTTP reutilizable para interactuar con la API del backend de autocode. Su objetivo es centralizar y simplificar la lógica de las peticiones fetch, gestionar errores de manera consistente y ofrecer métodos de conveniencia para los endpoints específicos de la aplicación.",
                              "last_modified": "2025-07-17T07:47:12.475523"
                            }
                          }
                        }
                      }
                    }
                  },
                  "files": {
                    "docs\\autocode\\web\\static\\app.md": {
                      "type": "file_doc",
                      "purpose": "Este archivo JavaScript es el orquestador principal del frontend de autocode. Su responsabilidad es dar vida a la interfaz de usuario, gestionando el estado de la aplicación, la comunicación con la API, la actualización dinámica del DOM y la interacción del usuario en las diferentes páginas.",
                      "last_modified": "2025-07-17T07:55:59.665820"
                    },
                    "docs\\autocode\\web\\static\\design-tokens.md": {
                      "type": "file_doc",
                      "purpose": "Este archivo CSS establece el sistema de diseño para la interfaz de usuario de Autocode. Centraliza todas las decisiones de diseño fundamentales (colores, tipografía, espaciado, etc.) en forma de CSS Custom Properties (variables CSS). Su propósito es garantizar una apariencia visual consistente, facilitar el mantenimiento y permitir la tematización (como el modo oscuro).",
                      "last_modified": "2025-07-16T17:07:49.508725"
                    },
                    "docs\\autocode\\web\\static\\style.md": {
                      "type": "file_doc",
                      "purpose": "Este archivo CSS define la apariencia visual y el layout de todos los componentes del dashboard de monitoreo de autocode. Su responsabilidad es tomar los valores del sistema de diseño (definidos en design-tokens.css) y aplicarlos para construir una interfaz de usuario cohesiva, profesional y responsiva.",
                      "last_modified": "2025-07-17T07:56:35.398336"
                    }
                  }
                },
                "docs\\autocode\\web\\templates/": {
                  "type": "module",
                  "module_file": "docs\\autocode\\web\\templates\\_module.md",
                  "purpose": "Este módulo contiene todas las plantillas HTML de Jinja2 que construyen la interfaz de usuario de la aplicación web autocode. Su responsabilidad es definir la estructura, el layout y los componentes visuales, separando la presentación de la lógica del servidor.",
                  "last_modified": "2025-07-17T07:52:54.364069",
                  "subdirectories": {
                    "docs\\autocode\\web\\templates\\components/": {
                      "type": "module",
                      "module_file": "docs\\autocode\\web\\templates\\components\\_module.md",
                      "purpose": "Este módulo contiene todos los componentes de UI reutilizables de la aplicación, definidos como plantillas de Jinja2. Su propósito es encapsular fragmentos de HTML en piezas modulares y configurables (a menudo como macros) que pueden ser fácilmente incluidas o importadas en las plantillas de página principales. Esto promueve la reutilización de código y un desarrollo de la interfaz más limpio y mantenible.",
                      "last_modified": "2025-07-17T07:52:03.077105",
                      "files": {
                        "docs\\autocode\\web\\templates\\components\\check_card.md": {
                          "type": "file_doc",
                          "purpose": "Este archivo define una macro de Jinja2 llamada check_card. Su propósito es generar un componente de UI reutilizable (una \"tarjeta\") que muestra el estado y los detalles de una verificación específica del sistema autocode (e.g., doc, test, git). La tarjeta es dinámica y adapta su contenido según el tipo de verificación que representa.",
                          "last_modified": "2025-07-17T07:48:12.386346"
                        },
                        "docs\\autocode\\web\\templates\\components\\footer.md": {
                          "type": "file_doc",
                          "purpose": "Este archivo define el componente de pie de página (<footer>) para la interfaz web de autocode. Su propósito es mostrar información dinámica sobre el estado de la aplicación, como la hora de la última actualización y el estado del refresco automático.",
                          "last_modified": "2025-07-17T07:48:37.418181"
                        },
                        "docs\\autocode\\web\\templates\\components\\header.md": {
                          "type": "file_doc",
                          "purpose": "Este archivo define el componente de cabecera (<header>) para la interfaz web de autocode. Su propósito es proporcionar una barra superior consistente en toda la aplicación, mostrando el título del proyecto, un subtítulo, y estadísticas clave del estado del sistema, como la conexión con el daemon de fondo.",
                          "last_modified": "2025-07-17T07:49:00.176908"
                        },
                        "docs\\autocode\\web\\templates\\components\\stat_card.md": {
                          "type": "file_doc",
                          "purpose": "Este archivo define una macro de Jinja2, stat_card, extremadamente simple y reutilizable. Su único propósito es generar un pequeño componente de UI para mostrar una estadística individual, que consiste en una etiqueta (label) y un valor.",
                          "last_modified": "2025-07-17T07:49:22.449554"
                        },
                        "docs\\autocode\\web\\templates\\components\\ui_designer.md": {
                          "type": "file_doc",
                          "purpose": "Este archivo define el componente principal de la interfaz de usuario para el \"Visor de Documentación de Diseño\". Su propósito es proporcionar la estructura HTML para la página donde los usuarios pueden cargar, visualizar e interactuar con los diagramas de arquitectura y diseño generados por autocode.",
                          "last_modified": "2025-07-17T07:49:47.095880"
                        }
                      }
                    },
                    "docs\\autocode\\web\\templates\\pages/": {
                      "type": "module",
                      "module_file": "docs\\autocode\\web\\templates\\pages\\_module.md",
                      "purpose": "Este módulo contiene las plantillas de Jinja2 que definen las páginas principales y completas de la aplicación web autocode. Cada archivo en este directorio representa una vista o ruta accesible para el usuario, y su principal responsabilidad es ensamblar los componentes de UI necesarios sobre la plantilla base para construir una página cohesiva y funcional.",
                      "last_modified": "2025-07-17T07:52:24.257828",
                      "files": {
                        "docs\\autocode\\web\\templates\\pages\\dashboard.md": {
                          "type": "file_doc",
                          "purpose": "Este archivo define la página principal de la aplicación: el Dashboard de Monitoreo. Su propósito es ofrecer una vista centralizada del estado del sistema autocode, mostrando estadísticas generales, el estado de las verificaciones individuales (documentación, tests, git) y permitiendo la configuración en tiempo real de estas verificaciones.",
                          "last_modified": "2025-07-17T07:50:17.232095"
                        },
                        "docs\\autocode\\web\\templates\\pages\\ui_designer.md": {
                          "type": "file_doc",
                          "purpose": "Este archivo define la página del \"UI Designer\" o \"Visor de Documentación de Diseño\". Su propósito principal es actuar como un contenedor o \"cáscara\" que hereda el layout general de la aplicación y carga el componente específico del visor de diseño y su script asociado.",
                          "last_modified": "2025-07-17T07:50:39.055481"
                        }
                      }
                    }
                  },
                  "files": {
                    "docs\\autocode\\web\\templates\\base.md": {
                      "type": "file_doc",
                      "purpose": "Este archivo es la plantilla maestra o \"layout\" principal para toda la interfaz web de autocode. Su propósito es definir la estructura HTML común a todas las páginas, incluyendo la cabecera, el pie de página, la barra de navegación lateral y las áreas de contenido dinámico. Garantiza una apariencia y estructura consistentes en toda la aplicación.",
                      "last_modified": "2025-07-17T07:47:41.762015"
                    },
                    "docs\\autocode\\web\\templates\\index.md": {
                      "type": "file_doc",
                      "purpose": "Este archivo es la plantilla HTML principal para el dashboard de monitoreo de autocode. Su propósito es definir la estructura y el layout de la interfaz de usuario que se muestra en el navegador. Actúa como el \"esqueleto\" de la página, que luego es poblado con datos dinámicos por el script app.js.",
                      "last_modified": "2025-07-16T17:15:30.075706"
                    }
                  }
                }
              }
            }
          },
          "files": {
            "docs\\autocode\\cli.md": {
              "type": "file_doc",
              "purpose": "Este módulo proporciona una interfaz de línea de comandos (CLI) unificada para acceder a todas las funcionalidades del sistema autocode. Actúa como el punto de entrada principal para que los usuarios y los sistemas de automatización (como CI/CD) interactúen con las herramientas de análisis y generación.",
              "last_modified": "2025-07-16T17:12:36.444334"
            }
          }
        },
        "docs\\examples/": {
          "type": "module",
          "module_file": "docs\\examples\\_module.md",
          "purpose": "Este módulo contiene ejemplos prácticos y casos de uso que demuestran cómo utilizar autocode tanto programáticamente como desde la línea de comandos. Su responsabilidad principal es proporcionar código ejecutable que sirva como referencia, tutorial y punto de partida para los desarrolladores que quieran integrar autocode en sus proyectos o flujos de trabajo.",
          "last_modified": "2025-07-16T17:17:50.709219",
          "files": {
            "docs\\examples\\basic_usage.md": {
              "type": "file_doc",
              "purpose": "Este script de ejemplo demuestra cómo utilizar las funcionalidades principales de autocode de forma programática, es decir, importando y utilizando sus clases directamente desde otro script de Python, en lugar de a través de la línea de comandos.",
              "last_modified": "2025-07-16T17:16:31.763761"
            }
          }
        }
      }
    }
  }
}